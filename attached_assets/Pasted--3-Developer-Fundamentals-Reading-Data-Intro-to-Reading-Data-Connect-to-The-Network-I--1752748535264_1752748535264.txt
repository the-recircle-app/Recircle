

3. Developer Fundamentals

Reading Data
Intro to Reading Data

Connect to The Network

I. Read Blocks

II. Read Transactions

III. Read Accounts

IV. States & Views

V. Events & Logs

VI. VET Transfers

Writing Data
Intro to Writing Data

I. Transactions

II. Fee Delegation

Listening to Changes
Intro to Listening to Changes

I. Events

II. VET Transfers

III. Transaction Log

IV. Blocks

V. Beats





W
W
Every change on the Blockchain requires a transaction. A transaction wraps function calls in the form of clauses. Each clause sends instructions to an address that is encoded as a hex string.

To send a transaction, you will need to complete multiple steps:



Have the Private Key at hand that will sign the transaction

Encode the function calls into data calls

Calculate how much gas the transaction will cost

Build a transaction object with all the previous information

Sign the transaction

Send the transaction to the network



Before moving on to learning about encoding the function calls into data calls, make sure to have your VeWorld Wallet set up. That'll cover step 1 of this lesson.



Now that we've covered the basic intro, let's look at encoding function calls.

The instructions for executing a function on the blockchain need to be encoded in a certain way. There are different functions to help create the right format, one is the clauseBuilder that will, in this example, call increment() on the given address:

code editor
const clauses = [
  clauseBuilder.functionInteraction(
    '0x8384738c995d49c5b692560ae688fc8b51af1059',
    'increment()'
  ),
];
A clause can also send VET in the same action.

While reading on the blockchain is free, writing requires so-called gas fees. Gas is paid in VTHO, the secondary token on VeChain, which is generated by holding VET.

To calculate the right amount of gas for your transaction, you can use estimateGas.

code editor
const gasResult = await thor.gas.estimateGas(clauses);
If you expect your contracts to have different results based on the sender, you can also pass in the sender address as an optional second parameter.

Once you have instructions + costs, you'll wrap them together into a transaction object with buildTransactionBody.

code editor
const txBody = await thor.transactions.buildTransactionBody(
  clauses,
  gasResult.totalGas
);
There are several options that can optionally be passed as a third argument to enable fee delegation, dependency on other transactions, priority, and expiration. You will learn more about them in other sections.

Once a transaction is built, it needs to be signed by an entity that will execute all the code. This also makes the origin verifiable.

It is a four-step process:



Get Signer

Sign Transaction

Build Signed Transaction Object

Send & Track Transaction



Let's look at each step in more details.



1. Get Signer
code editor
const wallet = new ProviderInternalBaseWallet(
  [{ privateKey, address: senderAddress }]
);

const provider = new VeChainProvider(
  // Thor client used by the provider
  thorClient,

  // Internal wallet used by the provider (needed to call the getSigner() method)
  wallet,

  // Enable fee delegation
  false
);

const signer = await provider.getSigner(senderAddress);
2. Sign Transaction
And using the signer to sign the transaction:

code editor
const rawSignedTx = await signer.signTransaction(tx, privateKey);
3. Build Signed Transaction Object 
signTransaction returns the fully signed transaction that can already be published using a POST request to the /transactions endpoint of a VeChain node:

code editor
await fetch(`${nodeUrl}/transactions`, {
  method: 'POST',
  headers: {
    'content-type': 'application/json',
  },
  body: JSON.stringify({
    raw: rawSignedTx,
  }),
})
For submission by SDK, the raw hex string needs to be restored into a transaction object:

code editor
const signedTx = TransactionHandler.decode(
  Buffer.from(rawSignedTx.slice(2), 'hex'),
  true
);
4. Send & Track Transaction
The signed transaction can be published to the network using sendTransaction, which will post the data to the connected node:

code editor
const sendTransactionResult = await thor.transactions.sendTransaction(signedTx);
Wait for Results
sendTransaction returns a transaction ID that can be used to track the status of the newly published transaction. waitForTransaction will resolve with the full receipt as soon as the result is available:

code editor
const txReceipt = await thor.transactions.waitForTransaction(
  sendTransactionResult.id
);
The snippet below brings it all together and illustrates how you can build a transaction, estimate how much it costs, and sign it to execute the transaction on-chain. 

The snippet includes: 

Necessary packages and imports

Build a transaction

Encoded function calls

Calculate how much gas the transaction costs

Sign the transaction with fee delegation (covered in the next lesson)

code editor
import {
  ThorClient,
  VeChainProvider,
  ProviderInternalBaseWallet,
  signerUtils,
} from '@vechain/sdk-network';
import {
  ABIFunction,
  Address,
  Clause,
  HexUInt,
  Secp256k1,
  Transaction,
} from '@vechain/sdk-core';
import express from 'express';

// setup simple express server
const app = express();
app.use(express.json());
app.listen(3000);

app.post('/', (req, res) => {
  console.log('Incoming request', req.body);
  const transactionToSign = Transaction.decode(
    HexUInt.of(req.body.raw).bytes
  );
  const delegatedHash = transactionToSign.getSignatureHash(req.body.origin);
  const signature = HexUInt.of(
    Secp256k1.sign(delegatedHash, delegatorPrivateKey)
  ).toString();
  console.log('Signature', signature);

  res.json({ signature });
});

// build a transaction, signed with url fee delegation
const thor = ThorClient.at('https://testnet.vechain.org/');
const privateKey = await Secp256k1.generatePrivateKey();
const senderAddress = Address.ofPrivateKey(privateKey).toString();
const delegatorPrivateKey = await Secp256k1.generatePrivateKey();
const tx = await generateSampleTransaction();

const providerWithDelegationEnabled = new VeChainProvider(
  thor,
  new ProviderInternalBaseWallet(
    [
      {
        privateKey: privateKey,
        address: senderAddress,
      },
    ],
    {
      gasPayer: { gasPayerServiceUrl: 'https://sponsor-testnet.vechain.energy/by/90' },
    }
  ),

  // Enable fee delegation
  true
);
const signedTx = await (
  await providerWithDelegationEnabled.getSigner(senderAddress)
).signTransaction(
  signerUtils.transactionBodyToTransactionRequestInput(tx, senderAddress)
);
process.exit(0);

async function generateSampleTransaction() {
  // generate random key for this script
  const privateKey = await Secp256k1.generatePrivateKey();

  // build instructions to execute
  const incrementAbi = new ABIFunction({
    name: 'increment',
    inputs: [],
    outputs: [],
    constant: false,
    payable: false,
    type: 'function',
  });
  const clauses = [
    Clause.callFunction(
      '0x8384738c995d49c5b692560ae688fc8b51af1059',
      incrementAbi
    ),
  ];

  // estimate how much gas the transaction will cost
  const gasResult = await thor.gas.estimateGas(clauses);

  // build a transaction
  const tx = await thor.transactions.buildTransactionBody(
    clauses,
    gasResult.totalGas,
    {
      isDelegated: true,
    }
  );

  return tx;
}
Alternatively, you can see how this code snippet works on StackBlitz

Check how it works

Complete task
For each of the following statements, indicate whether it is True or False.


Test 1: Fill in the Blanks (Select From Options)

Complete the sentence by placing the correct words in the blanks.


Test 2: Fill in the Blanks (Select From Options)
What happens if a transaction does not include enough VTHO to cover gas fees?


Test 3: Single Choice




What is required to sign and send a transaction on VeChainThor?
(Select two correct answers)


Test 4: Multiple Choice




Next Lesson
